/**
 * Script de migraci√≥n para transferir im√°genes de /public/images a PostgreSQL
 * Convierte archivos locales a BYTEA y actualiza referencias en la base de datos
 * 
 * Uso:
 * - Desarrollo: npm run migrate:images
 * - Railway: node scripts/migrate-images-to-postgresql.js
 */

import { PrismaClient } from '@prisma/client';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const prisma = new PrismaClient();

// Configuraci√≥n de migraci√≥n
const MIGRATION_CONFIG = {
  // Directorio de im√°genes p√∫blicas
  publicImagesDir: path.join(__dirname, '../public/images'),
  
  // Subdirectorios a procesar
  subdirectories: ['news', 'team'],
  
  // Tipos MIME soportados
  supportedMimeTypes: {
    '.jpg': 'image/jpeg',
    '.jpeg': 'image/jpeg',
    '.png': 'image/png',
    '.webp': 'image/webp',
    '.gif': 'image/gif',
    '.svg': 'image/svg+xml'
  },
  
  // Tama√±o m√°ximo (5MB)
  maxFileSize: 5 * 1024 * 1024,
  
  // Modo de ejecuci√≥n
  dryRun: process.env.DRY_RUN === 'true',
  verbose: process.env.VERBOSE === 'true'
};

/**
 * Obtiene el tipo MIME basado en la extensi√≥n del archivo
 */
function getMimeType(filePath) {
  const ext = path.extname(filePath).toLowerCase();
  return MIGRATION_CONFIG.supportedMimeTypes[ext] || null;
}

/**
 * Valida si un archivo es una imagen soportada
 */
async function validateImageFile(filePath) {
  try {
    const stats = await fs.stat(filePath);
    
    // Verificar tama√±o
    if (stats.size > MIGRATION_CONFIG.maxFileSize) {
      return { valid: false, error: `Archivo muy grande: ${stats.size} bytes` };
    }
    
    // Verificar tipo MIME
    const mimeType = getMimeType(filePath);
    if (!mimeType) {
      return { valid: false, error: `Tipo de archivo no soportado: ${path.extname(filePath)}` };
    }
    
    return { valid: true, mimeType, size: stats.size };
  } catch (error) {
    return { valid: false, error: `Error accediendo archivo: ${error.message}` };
  }
}

/**
 * Lee un archivo de imagen y lo convierte a Buffer
 */
async function readImageAsBuffer(filePath) {
  try {
    const buffer = await fs.readFile(filePath);
    return buffer;
  } catch (error) {
    throw new Error(`Error leyendo archivo ${filePath}: ${error.message}`);
  }
}

/**
 * Busca archivos de imagen en un directorio
 */
async function findImageFiles(directory) {
  try {
    const files = await fs.readdir(directory);
    const imageFiles = [];
    
    for (const file of files) {
      const filePath = path.join(directory, file);
      const stats = await fs.stat(filePath);
      
      if (stats.isFile()) {
        const mimeType = getMimeType(filePath);
        if (mimeType) {
          imageFiles.push({
            filename: file,
            fullPath: filePath,
            relativePath: path.relative(MIGRATION_CONFIG.publicImagesDir, filePath),
            mimeType,
            size: stats.size
          });
        }
      }
    }
    
    return imageFiles;
  } catch {
    console.warn(`‚ö†Ô∏è  Directorio no encontrado: ${directory}`);
    return [];
  }
}

/**
 * Migra im√°genes de noticias
 */
async function migrateNewsImages() {
  console.log('üì∞ Iniciando migraci√≥n de im√°genes de noticias...');
  
  const newsImagesDir = path.join(MIGRATION_CONFIG.publicImagesDir, 'news');
  const imageFiles = await findImageFiles(newsImagesDir);
  
  if (imageFiles.length === 0) {
    console.log('‚ÑπÔ∏è  No se encontraron im√°genes de noticias para migrar');
    return { processed: 0, errors: 0 };
  }
  
  console.log(`üìÅ Encontradas ${imageFiles.length} im√°genes de noticias`);
  
  let processed = 0;
  let errors = 0;
  
  // Obtener todas las noticias existentes
  const allNews = await prisma.news.findMany({
    select: { id: true, title: true, slug: true, imageUrl: true }
  });
  
  for (const imageFile of imageFiles) {
    try {
      console.log(`üîÑ Procesando: ${imageFile.filename}`);
      
      // Validar archivo
      const validation = await validateImageFile(imageFile.fullPath);
      if (!validation.valid) {
        console.error(`‚ùå Error validando ${imageFile.filename}: ${validation.error}`);
        errors++;
        continue;
      }
      
      // Leer archivo como buffer
      const imageBuffer = await readImageAsBuffer(imageFile.fullPath);
      
      // Buscar noticia que use esta imagen
      const publicPath = `/images/${imageFile.relativePath.replace(/\\/g, '/')}`;
      const matchingNews = allNews.find(news => 
        news.imageUrl === publicPath || 
        news.imageUrl?.includes(imageFile.filename)
      );
      
      if (matchingNews) {
        // Actualizar noticia existente
        if (!MIGRATION_CONFIG.dryRun) {
          await prisma.news.update({
            where: { id: matchingNews.id },
            data: {
              imageData: imageBuffer,
              imageType: validation.mimeType,
              imageUrl: `/api/images/${matchingNews.id}` // Nueva URL de API
            }
          });
        }
        
        console.log(`‚úÖ Migrada: ${imageFile.filename} ‚Üí Noticia: ${matchingNews.title}`);
        console.log(`   üîó Nueva URL: /api/images/${matchingNews.id}`);
        processed++;
      } else {
        // Imagen sin noticia asociada
        console.log(`‚ö†Ô∏è  Imagen hu√©rfana: ${imageFile.filename} (no hay noticia asociada)`);
        
        if (MIGRATION_CONFIG.verbose) {
          console.log(`   üíæ Guardando como imagen independiente...`);
          
          // Opcionalmente crear entrada independiente (comentado por seguridad)
          /*
          if (!MIGRATION_CONFIG.dryRun) {
            const newNews = await prisma.news.create({
              data: {
                title: `Imagen migrada: ${path.parse(imageFile.filename).name}`,
                slug: `migrated-image-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                excerpt: 'Imagen migrada autom√°ticamente desde /public/images',
                content: 'Esta imagen fue migrada autom√°ticamente al sistema PostgreSQL.',
                author: 'Sistema de migraci√≥n',
                category: 'migraci√≥n',
                tags: '["migraci√≥n", "autom√°tico"]',
                published: false,
                imageData: imageBuffer,
                imageType: validation.mimeType,
                imageUrl: `/api/images/${newNews.id}`
              }
            });
            console.log(`   ‚úÖ Creada entrada: /api/images/${newNews.id}`);
          }
          */
        }
      }
      
    } catch (error) {
      console.error(`‚ùå Error procesando ${imageFile.filename}: ${error.message}`);
      errors++;
    }
  }
  
  return { processed, errors, total: imageFiles.length };
}

/**
 * Migra im√°genes del equipo (para futuro uso)
 */
async function migrateTeamImages() {
  console.log('üë• Iniciando migraci√≥n de im√°genes del equipo...');
  
  const teamImagesDir = path.join(MIGRATION_CONFIG.publicImagesDir, 'team');
  const imageFiles = await findImageFiles(teamImagesDir);
  
  if (imageFiles.length === 0) {
    console.log('‚ÑπÔ∏è  No se encontraron im√°genes del equipo para migrar');
    return { processed: 0, errors: 0 };
  }
  
  console.log(`üìÅ Encontradas ${imageFiles.length} im√°genes del equipo`);
  console.log('‚ÑπÔ∏è  Migraci√≥n de equipo no implementada en esta versi√≥n');
  
  // TODO: Implementar cuando el modelo TeamMember tenga campos imageData/imageType
  return { processed: 0, errors: 0, total: imageFiles.length };
}

/**
 * Funci√≥n principal de migraci√≥n
 */
async function runMigration() {
  console.log('üöÄ INICIANDO MIGRACI√ìN DE IM√ÅGENES A POSTGRESQL');
  console.log('================================================');
  console.log(`üìÖ Fecha: ${new Date().toISOString()}`);
  console.log(`üîß Modo: ${MIGRATION_CONFIG.dryRun ? 'DRY RUN (no se guardar√°n cambios)' : 'PRODUCCI√ìN'}`);
  console.log(`üìÅ Directorio: ${MIGRATION_CONFIG.publicImagesDir}`);
  console.log('');
  
  try {
    // Verificar conexi√≥n a base de datos
    console.log('üîå Verificando conexi√≥n a PostgreSQL...');
    await prisma.$connect();
    console.log('‚úÖ Conexi√≥n establecida');
    console.log('');
    
    const results = {
      news: { processed: 0, errors: 0, total: 0 },
      team: { processed: 0, errors: 0, total: 0 }
    };
    
    // Migrar im√°genes de noticias
    results.news = await migrateNewsImages();
    console.log('');
    
    // Migrar im√°genes del equipo
    results.team = await migrateTeamImages();
    console.log('');
    
    // Resumen final
    console.log('üìä RESUMEN DE MIGRACI√ìN');
    console.log('========================');
    console.log(`üì∞ Noticias: ${results.news.processed}/${results.news.total} migradas, ${results.news.errors} errores`);
    console.log(`üë• Equipo: ${results.team.processed}/${results.team.total} migradas, ${results.team.errors} errores`);
    
    const totalProcessed = results.news.processed + results.team.processed;
    const totalErrors = results.news.errors + results.team.errors;
    const totalFiles = results.news.total + results.team.total;
    
    console.log('');
    console.log(`üéØ TOTAL: ${totalProcessed}/${totalFiles} archivos migrados exitosamente`);
    
    if (totalErrors > 0) {
      console.log(`‚ö†Ô∏è  ${totalErrors} errores encontrados (revisar logs arriba)`);
    }
    
    if (MIGRATION_CONFIG.dryRun) {
      console.log('');
      console.log('üîç MODO DRY RUN: No se realizaron cambios en la base de datos');
      console.log('   Para ejecutar la migraci√≥n real, ejecuta: DRY_RUN=false npm run migrate:images');
    } else {
      console.log('');
      console.log('‚úÖ MIGRACI√ìN COMPLETADA');
      console.log('   Las im√°genes ahora est√°n almacenadas en PostgreSQL');
      console.log('   Las URLs han sido actualizadas a /api/images/[id]');
    }
    
  } catch (error) {
    console.error('üí• ERROR CR√çTICO EN LA MIGRACI√ìN:');
    
    // Manejo espec√≠fico de errores de conexi√≥n
    if (error.code === 'P1000' || error.message?.includes('Authentication failed')) {
      console.error('üîí Error de autenticaci√≥n PostgreSQL:');
      console.error('   - Verificar que DATABASE_URL est√© configurada');
      console.error('   - Confirmar que la base de datos est√© accesible');
      console.error('   - En desarrollo local, asegurar PostgreSQL ejecut√°ndose');
      console.error('   - En Railway, verificar variables de entorno');
    } else if (error.code === 'ENOTFOUND' || error.message?.includes('connect')) {
      console.error('üåê Error de conexi√≥n de red:');
      console.error('   - Verificar conectividad a la base de datos');
      console.error('   - Confirmar que el host PostgreSQL est√© disponible');
    } else {
      console.error('‚ö†Ô∏è  Error desconocido:');
      console.error(error);
    }
    
    console.error('');
    console.error('üí° SOLUCIONES RECOMENDADAS:');
    console.error('   1. Verificar variables de entorno DATABASE_URL');
    console.error('   2. Confirmar que PostgreSQL est√© ejecut√°ndose');
    console.error('   3. Ejecutar este script en Railway donde la BD est√° disponible');
    console.error('   4. Usar Railway CLI: railway run npm run migrate:images:dry');
    
    process.exit(1);
  } finally {
    await prisma.$disconnect();
  }
}

// Ejecutar migraci√≥n si el script es llamado directamente
if (import.meta.url === `file://${process.argv[1]}`) {
  runMigration()
    .then(() => {
      console.log('');
      console.log('üèÅ Migraci√≥n finalizada');
      process.exit(0);
    })
    .catch((error) => {
      console.error('üí• Error fatal:', error);
      process.exit(1);
    });
}

export { runMigration, migrateNewsImages, migrateTeamImages };
